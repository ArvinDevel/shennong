package me.jinsui.shennong.bench.source;

import com.google.common.util.concurrent.RateLimiter;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.concurrent.ThreadLocalRandom;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import me.jinsui.shennong.bench.utils.AvroSerializer;
import org.apache.avro.Schema;
import org.apache.avro.generic.GenericData;
import org.apache.avro.generic.GenericRecord;

/**
 * Return data generated by self defined schema, and user can specify bytes column size.
 * Basic type use solid len, and bytes has variable len, used for solid/variable len exp
 */
@Slf4j
public class CustomDataSource implements DataSource<GenericRecord> {

    private final String schemaFile;
    private final RateLimiter rateLimiter;
    private int bytesSize;
    private int msgSize;
    @Getter
    private Schema schema;
    int estimatedSize = 0;
    private final GenericRecord mockRecord;

    public CustomDataSource(double rate, String schemaFile, int bytesSize) {
        this.schemaFile = schemaFile;
        this.bytesSize = bytesSize;
        this.rateLimiter = RateLimiter.create(rate);
        this.mockRecord = getMockData();
        this.msgSize = new AvroSerializer<>().serialize("", mockRecord).length;
        log.info("custom generic record estimated size {}, serialized size {}", estimatedSize, msgSize);
    }

    private GenericRecord getMockData() {
        try {
            schema = new Schema.Parser().parse(new File(schemaFile));
        } catch (IOException ioe) {
            log.error("Construct schema fail", ioe);
            System.exit(-1);
            return null;
        }
        log.error("schema is {}", schema);
        GenericRecord customRecord = new GenericData.Record(schema);
        for (Schema.Field field : schema.getFields()) {
            switch (field.schema().getType()) {
                case INT:
                    customRecord.put(field.name(), ThreadLocalRandom.current().nextInt());
                    estimatedSize += 4;
                    break;
                case LONG:
                    customRecord.put(field.name(), ThreadLocalRandom.current().nextLong());
                    estimatedSize += 8;
                    break;
                case BOOLEAN:
                    customRecord.put(field.name(), ThreadLocalRandom.current().nextBoolean());
                    estimatedSize += 1;
                    break;
                case FLOAT:
                    customRecord.put(field.name(), ThreadLocalRandom.current().nextFloat());
                    estimatedSize += 4;
                    break;
                case DOUBLE:
                    customRecord.put(field.name(), ThreadLocalRandom.current().nextDouble());
                    estimatedSize += 8;
                    break;
                case BYTES:
                    byte[] bytes = new byte[bytesSize];
                    ThreadLocalRandom.current().nextBytes(bytes);
                    customRecord.put(field.name(), ByteBuffer.wrap(bytes));
                    estimatedSize += bytesSize;
                    break;
                default:
                    log.error("{} is Not Supported, since it doesn't effect entire record(such as string, eg. char[], " +
                        "which is indeed like byte[]).", field.schema().getType());
            }
        }
        return customRecord;
    }

    @Override
    public boolean hasNext() {
        return rateLimiter.tryAcquire(msgSize);
    }

    public GenericRecord getNext() {
        return mockRecord;
    }

    @Override
    public int getEventSize() {
        return msgSize;
    }
}
